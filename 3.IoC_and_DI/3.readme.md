### Инверсия управления
Есть 2 типа инферсии управления (IoC):
1. Поиск зависимостей. Когда зависимый компонент получает ссылку на зависимость
   1. Извлечение зависимостей (_JNDI API_). Пример есть во второй главе - `HelloWorldSpring`.
   ![img.png](img.png)
   2. Контекстный поиск зависимостей (_CDL_). Пример в `contextlookup`.
   ![img_1.png](img_1.png)
2. Вндрение зависимостей. Зависимость внедряется контейнером инверсии управления
   1. Через конструктор. Когда зависимости предоставляются в конструкторе. Делает зависимости обязательными. Пример в 
   `constructorinjection`
   2. Через метод установки. В стиле JavaBeans. Пример в `setterinjection`. 
   3. Через поле, с помощью `@Autowired`
   
По факту всегда используется внедрение зависимостей.

Через конструктор - экземпляр должен существовать перед применением компонента. Помогает при неизменяемых объектах.

Через сеттер - для всего остального в принципе. Также можно объявить сеттеры в интерфейсе. 

Также через сеттеры можно определять конфигурационные данные, влияющие на все реализации конкретного интерфейса. Пример 

`
public interface NewsletterSender {
void setSmtpServer(String smtpServer);
String getSmtpServer();

    void setFromAddress(String fromAddress); 
    String getFromAddress();

    void send(); 
}
`

Это также является примером внедрения **пассивных** зависимостей, которые не используются напрямую для выполения 
конкретного действия, но применяются внутренним образом (или передаются другим зависимостям). Для применения нужнов 
выяснить, используется ли параметр во всех реализациях.

### Внедрение зависимостей в Spring

Ядром служит интерфейс `BeanFactory`, оторый осуществляет управление всем компонентами `Spring Beans`. 

Обычно, все компоненты загружаются сами через `ApplicationContext`, но иногда требуется ручная настройка через классы, 
реализующие интерфейс `BeanDefinition`, которые можно прочитать через xml (`context.xml` из второго модуля) или через 
файл конфигурации (`AppConfiguration` из второго модуля).

`Spring Bean` можно получить по идентификатору или имени (имен может быть сколько угодно), и через них же устанавливать 
зависимости между бинами.

Можно кстати обойтись без контекста типа... Пример в `XmlConfigWithBeanFactory`.

`ApplicationContext` сам реализует интерфейс `BeanFactory`, плюс к этому АОП, i18n, обработка событий и т.п.

Далее поговорим про конфигурацию `ApplicationContext`.

Лучше прописывать внедрение зависимостей через аннотации, а всякие утилиты в xml файле.



