### Инверсия управления
Есть 2 типа инферсии управления (IoC):
1. Поиск зависимостей. Когда зависимый компонент получает ссылку на зависимость
   1. Извлечение зависимостей (_JNDI API_). Пример есть во второй главе - `HelloWorldSpring`.
   ![img.png](img.png)
   2. Контекстный поиск зависимостей (_CDL_). Пример в `contextlookup`.
   ![img_1.png](img_1.png)
2. Вндрение зависимостей. Зависимость внедряется контейнером инверсии управления
   1. Через конструктор. Когда зависимости предоставляются в конструкторе. Делает зависимости обязательными. Пример в 
   `constructorinjection`
   2. Через метод установки. В стиле JavaBeans. Пример в `setterinjection`. 
   3. Через поле, с помощью `@Autowired`
   
По факту всегда используется внедрение зависимостей.

Через конструктор - экземпляр должен существовать перед применением компонента. Помогает при неизменяемых объектах.

Через сеттер - для всего остального в принципе. Также можно объявить сеттеры в интерфейсе. 

Также через сеттеры можно определять конфигурационные данные, влияющие на все реализации конкретного интерфейса. Пример 

`
public interface NewsletterSender {
void setSmtpServer(String smtpServer);
String getSmtpServer();

    void setFromAddress(String fromAddress); 
    String getFromAddress();

    void send(); 
}
`

Это также является примером внедрения **пассивных** зависимостей, которые не используются напрямую для выполения 
конкретного действия, но применяются внутренним образом (или передаются другим зависимостям). Для применения нужнов 
выяснить, используется ли параметр во всех реализациях.

### Внедрение зависимостей в Spring

Ядром служит интерфейс `BeanFactory`, оторый осуществляет управление всем компонентами `Spring Beans`. 

Обычно, все компоненты загружаются сами через `ApplicationContext`, но иногда требуется ручная настройка через классы, 
реализующие интерфейс `BeanDefinition`, которые можно прочитать через xml (`context.xml` из второго модуля) или через 
файл конфигурации (`AppConfiguration` из второго модуля).

`Spring Bean` можно получить по идентификатору или имени (имен может быть сколько угодно), и через них же устанавливать 
зависимости между бинами.

Можно кстати обойтись без контекста типа... Пример в `XmlConfigWithBeanFactory`.

`ApplicationContext` сам реализует интерфейс `BeanFactory`, плюс к этому АОП, i18n, обработка событий и т.п.

Далее поговорим про конфигурацию `ApplicationContext`.

Лучше прописывать внедрение зависимостей через аннотации, а всякие утилиты в xml файле.

Дескриптор _context: <component-scan>_ говорит спрингу посмотреть код на предмет аннтотаций типа @Component в конкретном 
пакете. Тогда весь прикол в бинами в xml файле можно заменить как показано в примере `HelloWorldWithComponentScan` 
(только там конфигурация происходит в файле `HelloWorldConfiguration`, а не в xml). Тут интерфейс `ApplicationContext` 
реализует класс `GenericXmlApplicationContext`, который может загружать его с xml файлов (а в примере загружает с 
`AnnotationConfigApplicationContext`).

Если есть несколько файлов конфигурации xml, можно загрузить их все сразу при помощи аннотации `@ImportResource`.

Можно инжектить конфигурации в xml файле при помощи пространства имен _p_, как показано в _app-context-xml.xml_.

Вернемся к `MwssageProvider`. Что, если нужно менять сообщение от компонента к компоненту (конфигурировать внешним 
образом)? Добавим реализацию интерфейсу - `ConfigurableMessageProvider`. Теперь сообщение нужно определять в 
конструкторе. Как это использовать - `DeclareSpringComponents` с файлом _context-for-configurable-component.xml_.
В нем - два бина с азными id, _c_ - пространство имен для внедрения зависимостей через конструктор, и _0 - номер 
аргумента конструктора.




