### Инверсия управления
Есть 2 типа инферсии управления (IoC):
1. Поиск зависимостей. Когда зависимый компонент получает ссылку на зависимость
   1. Извлечение зависимостей (_JNDI API_). Пример есть во второй главе - `HelloWorldSpring`.
   ![img.png](img.png)
   2. Контекстный поиск зависимостей (_CDL_). Пример в `contextlookup`.
   ![img_1.png](img_1.png)
2. Вндрение зависимостей. Зависимость внедряется контейнером инверсии управления
   1. Через конструктор. Когда зависимости предоставляются в конструкторе. Делает зависимости обязательными. Пример в 
   `constructorinjection`
   2. Через метод установки. В стиле JavaBeans. Пример в `setterinjection`. 
   3. Через поле, с помощью `@Autowired`
   
По факту всегда используется внедрение зависимостей.

Через конструктор - экземпляр должен существовать перед применением компонента. Помогает при неизменяемых объектах.

Через сеттер - для всего остального в принципе. Также можно объявить сеттеры в интерфейсе. 

Также через сеттеры можно определять конфигурационные данные, влияющие на все реализации конкретного интерфейса. Пример 

`
public interface NewsletterSender {
void setSmtpServer(String smtpServer);
String getSmtpServer();

    void setFromAddress(String fromAddress); 
    String getFromAddress();

    void send(); 
}
`

Это также является примером внедрения **пассивных** зависимостей, которые не используются напрямую для выполения 
конкретного действия, но применяются внутренним образом (или передаются другим зависимостям). Для применения нужнов 
выяснить, используется ли параметр во всех реализациях.

### Внедрение зависимостей в Spring

Ядром служит интерфейс `BeanFactory`, оторый осуществляет управление всем компонентами `Spring Beans`. 

Обычно, все компоненты загружаются сами через `ApplicationContext`, но иногда требуется ручная настройка через классы, 
реализующие интерфейс `BeanDefinition`, которые можно прочитать через xml (`context.xml` из второго модуля) или через 
файл конфигурации (`AppConfiguration` из второго модуля).

`Spring Bean` можно получить по идентификатору или имени (имен может быть сколько угодно), и через них же устанавливать 
зависимости между бинами.

Можно кстати обойтись без контекста типа... Пример в `XmlConfigWithBeanFactory`.

`ApplicationContext` сам реализует интерфейс `BeanFactory`, плюс к этому АОП, i18n, обработка событий и т.п.

Далее поговорим про конфигурацию `ApplicationContext`.

Лучше прописывать внедрение зависимостей через аннотации, а всякие утилиты в xml файле.

Дескриптор _context: <component-scan>_ говорит спрингу посмотреть код на предмет аннтотаций типа @Component в конкретном 
пакете. Тогда весь прикол в бинами в xml файле можно заменить как показано в примере `HelloWorldWithComponentScan` 
(только там конфигурация происходит в файле `HelloWorldConfiguration`, а не в xml). Тут интерфейс `ApplicationContext` 
реализует класс `GenericXmlApplicationContext`, который может загружать его с xml файлов (а в примере загружает с 
`AnnotationConfigApplicationContext`).

Если есть несколько файлов конфигурации xml, можно загрузить их все сразу при помощи аннотации `@ImportResource`.

Можно инжектить конфигурации в xml файле при помощи пространства имен _p_, как показано в _app-context-xml.xml_.

Вернемся к `MwssageProvider`. Что, если нужно менять сообщение от компонента к компоненту (конфигурировать внешним 
образом)? Добавим реализацию интерфейсу - `ConfigurableMessageProvider`. Теперь сообщение нужно определять в 
конструкторе. Как это использовать - `DeclareSpringComponents` с файлом _context-for-configurable-component.xml_.
В нем - два бина с азными id, _c_ - пространство имен для внедрения зависимостей через конструктор, и _0 - номер 
аргумента конструктора.

Когда у конструктора оинаковое количество аргументов с одинаковыми типами, _Spring_ не шарит, какой нужен. Пример в 
`ConstructorConfusion`. Чтобы выйти из положения можно определить контекст с указанием типа аргумента конструктора
(type="int" в этом случае).

      <constructor-arg type="int">
         <value>90</value>
      </constructor-arg>

Или же через `@Autowired` и `@Value`.

Внедрение зависимостей через поле суперудобное, но есть ряд недостатков:
1. Трудно следить за принципом единственной ответственности, т.к. класс может слишком разрастись, и это не будет заметно
2. Нельзя больше получить компонент без Spring'a
3. Затрудняет написание тестов

Внедрять можно не только компоненты, но и простые значения. Либо как было показано раньше через `<value>` в _xml_, или 
через `@Value`, или через SpEL как показано в `InjectSimpleSpel`. Аргумент будет приводиться из String в любой примитив.
P.S. Как показано в `InjectSimpleSpel` полная хуйня, потому что я изменил имя `injectSimpleConstants` и отлавливал 
ошибку 10 минут.

Главное условие внедрения зависимостей - чтобы внедряемый компонент и целевой были совместимы (но не совпадали) (используй интерфейсы где
только можно и будет тебе счастье). Также можно внедрять через метод установки через _xml_ через аттрибут _ref_

      <bean id="injectRef"
      class="com.apress.prospringS.chЗ.xml.InjectRef">
      <property name="oracle">
      <ref bean="oracle"/>
      </property>
      </bean>

### Внедрение и вложение контекстов

Spring поддерживает иерархическую структуру для интерфейса `ApplicationConext` и для их фабрик типа `BeanFactory`. 
Значит, можно и контексты разносить по разным конфигурационным фалам. Назначить у контекста типа 
`GenericXmlApplicationContext` нужно просто вызвать метод `setParent()` и в аргумент впихуть другой контекст. Крутой 
пример в `HierarchicalAppContextUsage`.

### Внедрение коллекций








