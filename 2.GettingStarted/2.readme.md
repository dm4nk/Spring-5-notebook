http://spring.io/guides

Модули в *Spring*

---

**aop** - Поддержка аспектно-ориентированного программирования, поддержка интеграции с *AspectJ*. Должен быть включен в
проект, если планируется использовать другие модули *Spring*, в которых используется АОП.

---

**aspects** - Расширенная интеграция с *AspectJ*.

---
**defaultbeanusage** - Все классы для управления *Sring Beans*.

---

**conext** - Классы для расширения ядра *Spring*. Все классы используют интерфейс `ApplicationContext`, а также классы
для интеграции с *EJB*, *JNDI* и *JMX*, а также классы для удаленного взаимододействия и интеграции с языками
динамических сценариев, классы *Bean Validation*.

---

**cotext-support** - Расширение модуля **conext**. Классы для электронной почты, интеграции с шаблонизаторами и
библиотеками для выполнения заданий типа _CommonJ_ или _Quartz_.

---

**core** - Основной модуль, требующийся для каждого приложения, куда вынесен общий функционал остальных модулей.

---

**instrument** - Нужен для первоначальной загрузки _JVM_, и, возможно, для _AspectJ_.

---

**jdbc** - Все для _JDBC_... Нужен для всех приложений, которые будут работать с бд.

---

**orm** - Расширяет (и зависит от) **jdbc**, добавляя _Hibernate_, _JDO_, _JPA_.

---

**oxm** - Функционал для превращения объектов в _xml_ и наоборот.

---

**test** - Предоставляет ряд имитирующих классов, а также интеграцию с _JUnit_.

---

**tx** - Все для транзакций в _Spring_.

---

**web** - Для веба и автоматической загрузки контекста `ApplicationContext`.

---

**web-mvc** - Все классы для каркаса по проектному шаблону _MVC_.

---

**websocket** - Поддержка _Java API_ для _WebSocket_.

Напишем просто приложение Hello World, но предъявим к нему 2 требования:

1. Выводящеесся сообщение должно легко меняться.
2. Изменение способа вывода сообщения должно легко меняться.

Далее взгляд на пакет `helloworldwithmessageproviders`. Реализация обычного Hello World в стиле EJB с максимальной
независимостью программы от конкретных реализаций...

Но все равно, чтобы сменить конкретную реализацию, придется менять код. Выход из митуации - фабриыный класс. Тогда имена
классов, реализующих интерфейс будут читаться из файла свойств, а экземпляры получаются от имени данного приложения. Это
реализовано в `helloworldwithfactory`.

У этого примера есть недостаток - много связующего кода.

Перепишем все на _Spring_. Обошлись без `MessageSupportFactory`, результат в пакете `spring`.

Конкретные реализации классов хранятся в `ApplicationContext`. В файле `context.xml` хранится информация о конкретных
реализациях интерфейсов и о зависимостях от других компонент. Это немного устарешвая штука, поэтому ее следует заменить
аннотациями. 
